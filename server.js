const express = require('express')
const http = require('http')
const socketIo = require('socket.io')
const cors = require('cors')
const { subtle } = require('node:crypto').webcrypto
const { MessengerClient } = require('./messenger')
const {
  generateECDSA,
  generateEG,
  signWithECDSA,
  cryptoKeyToJSON
} = require('./lib')

const app = express()
const server = http.createServer(app)
const io = socketIo(server, {
  cors: {
    origin: 'http://127.0.0.1:5501',
    methods: ['GET', 'POST']
  }
})

app.use(cors({ origin: 'http://127.0.0.1:5501' }))
app.use(express.static('public')) // Serve static files from the "public" directory

// Store active users and their data
const users = {} // { username: { socket, client, cert, certSignature } }

let caKeyPair
let govKeyPair;

(async () => {
  // Generate the Certificate Authority and Government key pairs
  // generated by clients before relaying them to other clients
  caKeyPair = await generateECDSA()
  // keypair for the government to be able to decrypt all messages
  govKeyPair = await generateEG()
})()

// Utility to ensure a key is ECDH-compatible
async function ensureECDHKey (key) {
  try {
    return await subtle.importKey(
      'jwk',
      await cryptoKeyToJSON(key),
      { name: 'ECDH', namedCurve: 'P-384' },
      true,
      []
    )
  } catch (err) {
    throw new Error(`Invalid ECDH key: ${err.message}`)
  }
}
const stringifyCert = function (cert) {
  if (typeof cert === 'object') {
    return JSON.stringify(cert)
  } else if (typeof cert === 'string') {
    return cert
  } else {
    throw new Error('Certificate is not a JSON or string')
  }
}

// Handle user connections
io.on('connection', (socket) => {
  console.log('A user connected.')

  // Handle user registration
  socket.on('register', async (username) => {
    if (users[username]) {
      socket.emit('error', 'Username is already taken.')
      return
    }

    // Initialize a new MessengerClient for the user
    const client = new MessengerClient(caKeyPair.pub, govKeyPair.pub)
    const cert = await client.generateCertificate(username)
    const certSignature = await signWithECDSA(
      caKeyPair.sec,
      stringifyCert(cert)
    )

    users[username] = { socket, client, cert, certSignature }

    // Send certificate and success confirmation to the registering user
    socket.emit('registered', { cert, certSignature })

    // Notify other users about the new user
    for (const user in users) {
      if (user !== username) {
        users[user].socket.emit('userJoined', username)
      }
    }

    // Send the current user list to the new user (excluding themselves)
    const userList = Object.keys(users).filter((user) => user !== username)
    // Broadcast updated user list to all connected clients
    console.log('Updated user list broadcast:', userList);
    socket.emit('userList', userList)
    console.log('User registered:', username)
    // io.emit('userList', userList) 
  })

  socket.on('requestUserList', () => {
    const userList = Object.keys(users).filter(user => users[user].socket.id !== socket.id); // Get the latest list of users
    socket.emit('userList', userList);  // Send the list back to the requesting client
});

  // Handle requests for a certificate
  socket.on('requestCertificate', async ({ from, to }) => {
    if (!users[to]) {
      socket.emit('error', 'User not found.')
      return
    }
    console.log(`Exchanging certificates for ${from} and ${to}...`)
    const recipient = users[to]
    const senderClient = users[from].client
    await senderClient.receiveCertificate(
      recipient.cert,
      recipient.certSignature
    )
    const { cert, certSignature } = users[to]
    socket.emit('certificate', { to, cert, certSignature })
  })

  // Handle sending messages
  socket.on('sendMessage', async ({ from, to, message }) => {
    try {
      if (!users[to]) {
        socket.emit('error', 'Recipient not found.')
        return
      }

      const recipient = users[to]
      const senderClient = users[from].client

      // Ensure certificates are exchanged
      if (!senderClient.certs[to]) {
        console.log(`Exchanging certificates for ${from} and ${to}...`)
        await senderClient.receiveCertificate(
          recipient.cert,
          recipient.certSignature
        )
      }

      // Debug: Check the sender's and recipient's keys
      console.log(
        'Sender private key:',
        await cryptoKeyToJSON(senderClient.EGKeyPair.sec)
      )
      console.log('Recipient public key (raw):', recipient.cert.pub)

      // Ensure recipient's public key is valid for ECDH
      const recipientPubKey = await ensureECDHKey(recipient.cert.pub)
      console.log(
        'Recipient public key (validated):',
        await cryptoKeyToJSON(recipientPubKey)
      )

      // Send the encrypted message
      const encryptedMessage = await senderClient.sendMessage(
        to,
        message
      )
      console.log(
                `Encrypted message sent from ${from} to ${to}:`,
                encryptedMessage
      )

      // Log before emitting message to recipient
      console.log(
                `Sending encrypted message to recipient socket for user ${to}...`
      )

      // Decrypt the message for the recipient
      const recipientClient = recipient.client

      // Ensure the recipient's client has the necessary certificate
      if (!recipientClient.certs[from]) {
        console.log(`Exchanging certificates for ${to} and ${from}...`)
        await recipientClient.receiveCertificate(
          senderClient.cert,
          senderClient.certSignature
        )
      }

      // Decrypt the message
      const plaintext = await recipientClient.receiveMessage(
        from,
        encryptedMessage
      )
    //   console.log(`Decrypted message for ${to}: ${plaintext}`)

      // Emit the decrypted message to the recipient
      recipient.socket.emit('receiveMessage', {
        from,
        message: plaintext // Send the plaintext message
      })
    } catch (err) {
      console.error(`Error handling sendMessage: ${err.message}`)
      socket.emit('error', `Failed to send message: ${err.message}`)
    }
  })

  socket.on('receiveMessage', async ({ from, message }) => {
    try {
      const recipientClient = users[from]?.client
      if (!recipientClient) {
        console.error(`Recipient client not found for ${from}`)
        return
      }

      console.log(`Message received for ${from} from ${message}`)
      console.log('Attempting to decrypt the message...')

      // Process the message on the recipient's side
      const plaintext = await recipientClient.receiveMessage(
        from,
        message
      )

    //   console.log(`Decrypted message for ${from}:, plaintext`)

      // Optionally forward the plaintext to the recipient's UI
      const recipientSocket = users[from]?.socket
      if (recipientSocket) {
        recipientSocket.emit('decryptedMessage', {
          from,
          plaintext
        })
      }
    } catch (err) {
      console.error(
                `Error handling receiveMessage for ${from}: ${err.message}`
      )
    }
  })

  // Handle user disconnection
  socket.on('disconnect', () => {
    const disconnectedUser = Object.keys(users).find(
      (username) => users[username].socket.id === socket.id
    )
    if (disconnectedUser) {
      delete users[disconnectedUser]
      console.log(`${disconnectedUser} disconnected.`)
      io.emit('userLeft', disconnectedUser)
    }
  })
})

// Start the server
const PORT = 3000
server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`)
})